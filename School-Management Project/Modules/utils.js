function getCalendar(config) {	var    cal,    ERRORS,    calModule,    sessionRef,    calendarMeta,    directoryROLES;        config 			= ds.Utils.extend(__myNameSpace.Calendar, config);    calModule 		= require('iCalendar');    cal 			= new calModule.Calendar();    calendarMeta 	= config.meta;    ERRORS 			= __myNameSpace.ERRORS;    directoryROLES 	= __myNameSpace.DirectoryROLES;    sessionRef 		= currentSession();    if (!sessionRef.belongsTo(directoryROLES.LOGGEDIN)) {        return ERRORS.login.notConnected;    }    /********************** @Begin: Set the calendar attributes **********************/    for (var _attr in config ) {        if (config.hasOwnProperty(_attr) && _attr != 'meta') {            cal.getAttribute(_attr, true).setValue(config[_attr]);        }    }    try {        var        _attr,        calEvents,        eventMeta,        addTheEvent;                calEvents 	= calendarMeta.EVENT;        eventMeta 	= calendarMeta.EVENT.meta;        addTheEvent = false;        if (eventMeta && eventMeta.display) {            addTheEvent = true;        }        else if (eventMeta.display != false) {            addTheEvent = true;        }        if (addTheEvent) {            eval(calendarMeta.TimeTableDC).forEach(function(tt) {                var                event = new calModule.Event();                if (typeof eventMeta.display == 'function') {                    addTheEvent = eventMeta.display.call(calEvents, tt);                }                if (addTheEvent) {                    /********************** Set the event attributes **********************/                    for (_attr in calEvents) {                        if (calEvents.hasOwnProperty(_attr) && _attr != 'meta') {                            try {                                var                                regex = new RegExp(calEvents.meta.jocker, 'g'),                                str = calEvents[_attr].replace(regex, 'tt'),                                value = eval(str);                                event.getAttribute(_attr, true).setValue(value);                            }                            catch (e) {                                event.getAttribute(_attr, true).setValue(calEvents[_attr]);                            }                        }                    }                    if (calEvents.meta.alarm) {                        var                        alarm,                        calAlarm,                        addTheAlarm;                                                calAlarm 	= calEvents.meta.alarm;                        alarm 		= new calModule.Alarm();                        addTheAlarm = false;                        if (!calAlarm.meta) {                            addTheAlarm = true;                        }                        else if (calAlarm.meta.display) {                            var                            launcher = calAlarm.meta.display;                            switch (typeof launcher) {                                case 'function':                                    if (launcher.call(calAlarm, tt)) {                                        addTheAlarm = true;                                    }                                    break;                                default:                                    if (launcher) {                                        addTheAlarm = true;                                    }                                    break;                            }                        }                        else if (calAlarm.meta.display != false) {                            addTheAlarm = true;                        }                        if (addTheAlarm) {                            /********************** Set the alarm attributes **********************/                            for (_attr in calAlarm) {                                if (calAlarm.hasOwnProperty(_attr) && _attr != 'meta') {                                    alarm.getAttribute(_attr, true).setValue(calAlarm[_attr]);                                }                            }                            event.addItem(alarm);                        }                    }                    cal.addItem(event);                }            });        }    }    catch (e) {        return cal.toString();    }    return cal.toString();}function isBrowser(userAgent){	var	userAgents 	= ['mozilla' , 'dillo' , 'elink' , 'enigma' , 'galaxy' , 'hotjava' ,					'ibm webexplorer' , 'ibrowser' , 'icab' , 'leechcraft' , 'links' ,					'lynx' , 'uzbl' , 'surf' , 'sundance' , 'seamonkey' , 'vimprobable' , 					'w3m' , 'worldwideweb' , 'opera' , 'ncsa' , 'netsurf'];						function startWith( str , matcher){		return new RegExp("^" + matcher , 'i').test(str);	}		for(var _i = 0  , matcher ; matcher = userAgents[_i] ; _i++){		if(startWith(userAgent , matcher)){			return true;		}	}		return false;}function getVacancyTypes(withDetails){	var	type 	= __myNameSpace.School.TIME_TABLE.VACANCY_TYPES,	result	= [];		for(var i in type){		var obj;		if(withDetails){			obj = {				name	: i,				title	: type[i].title,				value	: type[i].value			}		}		else{			obj = type[i].value;		}				result.push(obj);	}		return result;}function getVacancyType(value){	var	type 	= __myNameSpace.School.TIME_TABLE.VACANCY_TYPES;		for(var i in type){		if(value == type[i].value){			return {				name	: i,				title	: type[i].title,				value	: type[i].value			}		}	}		return null;}function parseUri (str) {	var	o   = parseUri.options,		m   = o.parser[o.strictMode ? "strict" : "loose"].exec(str),		uri = {},		i   = 14;	while (i--) uri[o.key[i]] = m[i] || "";	uri[o.q.name] = {};	uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {		if ($1) uri[o.q.name][$1] = $2;	});	return uri;};parseUri.options = {	strictMode: false,	key: ["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],	q:   {		name:   "queryKey",		parser: /(?:^|&)([^&=]*)=?([^&]*)/g	},	parser: {		strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,		loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/	}};exports.parseUri = parseUri;exports.getCalendar = getCalendar;exports.isBrowser = isBrowser;exports.getVacancyTypes = getVacancyTypes;exports.getVacancyType = getVacancyType;